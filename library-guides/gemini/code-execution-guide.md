# Gemini API Code Execution Guide

## Overview
The Gemini API provides a code execution tool that enables models to generate and run Python code iteratively until arriving at a final output. This capability enables code-based reasoning for mathematical calculations, data processing, analysis, and specialized tasks using included libraries.

## Key Capabilities
- **Python Code Generation**: Model generates Python code to solve problems
- **Iterative Execution**: Model learns from execution results and refines code
- **File I/O Support**: Upload CSV/text files and generate matplotlib graphs (Gemini 2.0+)
- **Rich Library Support**: Access to scientific computing, data analysis, and visualization libraries
- **Multi-turn Conversations**: Use code execution in chat sessions

## Basic Setup

### JavaScript/TypeScript Implementation
```javascript
import { GoogleGenAI } from "@google/genai";

const ai = new GoogleGenAI({
  apiKey: process.env.GEMINI_API_KEY
});

async function executeCode(prompt) {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: prompt,
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  // Process different response parts
  const parts = response?.candidates?.[0]?.content?.parts || [];
  
  parts.forEach((part) => {
    if (part.text) {
      console.log("Text:", part.text);
    }
    if (part.executableCode && part.executableCode.code) {
      console.log("Generated Code:", part.executableCode.code);
    }
    if (part.codeExecutionResult && part.codeExecutionResult.output) {
      console.log("Execution Result:", part.codeExecutionResult.output);
    }
  });

  return response;
}

// Usage
const result = await executeCode(
  "What is the sum of the first 50 prime numbers? " +
  "Generate and run code for the calculation, and make sure you get all 50."
);
```

### Response Structure
The model returns three types of content parts:

1. **text**: Explanatory text from the model
2. **executableCode**: Python code generated by the model
3. **codeExecutionResult**: Output from running the code

## Mathematical Calculations

### Prime Number Analysis
```javascript
async function analyzePrimes() {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [
      "Find the first 20 prime numbers, calculate their sum, " +
      "and create a visualization showing their distribution."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

### Statistical Analysis
```javascript
async function performStatistics() {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [
      "Generate 1000 random numbers from a normal distribution, " +
      "calculate mean, median, standard deviation, and create a histogram."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

### Complex Mathematical Problems
```javascript
async function solveMathProblem() {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [
      "Solve the quadratic equation 2xÂ² + 5x - 3 = 0 using the quadratic formula. " +
      "Show all steps and verify the solution by substitution."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

## Data Processing and Analysis

### CSV Data Analysis
```javascript
async function analyzeCSVData() {
  // First upload a CSV file using the Files API
  const csvFile = await ai.files.upload({
    file: "path/to/sales_data.csv",
    config: { mimeType: "text/csv" }
  });

  const response = await ai.models.generateContent({
    model: "gemini-2.0-flash", // Required for file I/O
    contents: [
      {
        fileData: {
          mimeType: csvFile.mimeType,
          fileUri: csvFile.uri
        }
      },
      "Analyze this sales data. Calculate total revenue, average order value, " +
      "and create visualizations showing sales trends over time."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

### Text Processing
```javascript
async function processTextData() {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [
      "Create a function to analyze text sentiment, word frequency, " +
      "and reading level. Test it with a sample paragraph."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

## Data Visualization

### Creating Charts and Graphs
```javascript
async function createVisualization() {
  const response = await ai.models.generateContent({
    model: "gemini-2.0-flash", // Required for graph output
    contents: [
      "Create a dataset of monthly sales figures for a year. " +
      "Generate a line chart, bar chart, and pie chart showing different aspects of the data. " +
      "Use matplotlib with proper styling and labels."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  // Extract generated images from response
  const parts = response?.candidates?.[0]?.content?.parts || [];
  const images = parts.filter(part => part.inlineData && part.inlineData.mimeType?.startsWith('image/'));
  
  return { response, images };
}
```

### Scientific Plotting
```javascript
async function createScientificPlot() {
  const response = await ai.models.generateContent({
    model: "gemini-2.0-flash",
    contents: [
      "Plot the function f(x) = sin(x) * e^(-x/5) for x from 0 to 20. " +
      "Add a second subplot showing its derivative. " +
      "Use seaborn styling and include proper labels and legends."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

## Chat-Based Code Execution

### Multi-turn Problem Solving
```javascript
async function createCodeExecutionChat() {
  const chat = ai.chats.create({
    model: "gemini-2.5-flash",
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  // Initial problem setup
  let response = await chat.sendMessage({
    message: "I need to analyze some financial data. Let's start by creating a sample dataset."
  });
  console.log("Setup:", response.text);

  // Follow-up analysis
  response = await chat.sendMessage({
    message: "Now calculate the compound annual growth rate (CAGR) for this data and create a visualization."
  });
  console.log("Analysis:", response.text);

  // Additional insights
  response = await chat.sendMessage({
    message: "What insights can you derive from this data? Perform any additional statistical analysis that would be helpful."
  });
  console.log("Insights:", response.text);

  return chat;
}
```

### Iterative Development
```javascript
async function iterativeCoding() {
  const chat = ai.chats.create({
    model: "gemini-2.5-flash",
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  // Start with basic implementation
  let response = await chat.sendMessage({
    message: "Create a simple calculator class with basic arithmetic operations."
  });

  // Add more features
  response = await chat.sendMessage({
    message: "Now add scientific functions like sin, cos, log, and square root to the calculator."
  });

  // Test and validate
  response = await chat.sendMessage({
    message: "Create comprehensive tests for all calculator functions and run them."
  });

  return chat;
}
```

## Advanced Use Cases

### Machine Learning Tasks
```javascript
async function performMLAnalysis() {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [
      "Create a simple linear regression model using scikit-learn. " +
      "Generate sample data, train the model, evaluate its performance, " +
      "and create visualizations showing the results."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

### Image Processing
```javascript
async function processImages() {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [
      "Create a simple image processing pipeline using OpenCV and PIL. " +
      "Generate a sample image, apply filters, detect edges, and show the results."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

### Document Generation
```javascript
async function generateDocuments() {
  const response = await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [
      "Create a PDF report using reportlab that includes: " +
      "1. A title page with company info " +
      "2. A data table with sample sales figures " +
      "3. A chart showing trends " +
      "4. A summary section with key insights"
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

## File Input/Output (Gemini 2.0+)

### Working with Uploaded Files
```javascript
async function analyzeUploadedFile() {
  // Upload a data file
  const dataFile = await ai.files.upload({
    file: "path/to/data.csv",
    config: { mimeType: "text/csv" }
  });

  const response = await ai.models.generateContent({
    model: "gemini-2.0-flash",
    contents: [
      {
        fileData: {
          mimeType: dataFile.mimeType,
          fileUri: dataFile.uri
        }
      },
      "Analyze this dataset and create comprehensive visualizations. " +
      "Include summary statistics, correlation analysis, and trend identification."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  // Extract any generated images
  const parts = response?.candidates?.[0]?.content?.parts || [];
  const generatedImages = parts.filter(part => 
    part.inlineData && part.inlineData.mimeType?.startsWith('image/')
  );

  return { response, images: generatedImages };
}
```

### Multi-file Analysis
```javascript
async function compareDatasets() {
  const file1 = await ai.files.upload({
    file: "path/to/dataset1.csv",
    config: { mimeType: "text/csv" }
  });

  const file2 = await ai.files.upload({
    file: "path/to/dataset2.csv", 
    config: { mimeType: "text/csv" }
  });

  const response = await ai.models.generateContent({
    model: "gemini-2.0-flash",
    contents: [
      {
        fileData: {
          mimeType: file1.mimeType,
          fileUri: file1.uri
        }
      },
      {
        fileData: {
          mimeType: file2.mimeType,
          fileUri: file2.uri
        }
      },
      "Compare these two datasets. Identify similarities, differences, " +
      "and create side-by-side visualizations for comparison."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

## Error Handling and Best Practices

### Robust Code Execution
```javascript
async function safeCodeExecution(prompt, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: prompt,
        config: {
          tools: [{ codeExecution: {} }],
        },
      });

      // Check if code execution was successful
      const parts = response?.candidates?.[0]?.content?.parts || [];
      const executionResult = parts.find(part => part.codeExecutionResult);
      
      if (executionResult && executionResult.codeExecutionResult.outcome === "OUTCOME_OK") {
        return response;
      } else if (executionResult) {
        console.warn(`Code execution failed on attempt ${attempt}:`, executionResult.codeExecutionResult.output);
      }

      if (attempt === maxRetries) {
        throw new Error("Code execution failed after maximum retries");
      }
    } catch (error) {
      console.error(`Attempt ${attempt} failed:`, error.message);
      if (attempt === maxRetries) {
        throw error;
      }
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    }
  }
}
```

### Processing Response Parts
```javascript
function processCodeExecutionResponse(response) {
  const parts = response?.candidates?.[0]?.content?.parts || [];
  const result = {
    text: [],
    code: [],
    output: [],
    images: [],
    errors: []
  };

  parts.forEach((part) => {
    if (part.text) {
      result.text.push(part.text);
    }
    
    if (part.executableCode) {
      result.code.push({
        language: part.executableCode.language,
        code: part.executableCode.code
      });
    }
    
    if (part.codeExecutionResult) {
      if (part.codeExecutionResult.outcome === "OUTCOME_OK") {
        result.output.push(part.codeExecutionResult.output);
      } else {
        result.errors.push(part.codeExecutionResult.output);
      }
    }
    
    if (part.inlineData && part.inlineData.mimeType?.startsWith('image/')) {
      result.images.push({
        mimeType: part.inlineData.mimeType,
        data: part.inlineData.data
      });
    }
  });

  return result;
}

// Usage
const response = await executeCode("Create a bar chart of sample data");
const processed = processCodeExecutionResponse(response);
console.log("Generated code:", processed.code);
console.log("Execution output:", processed.output);
console.log("Generated images:", processed.images.length);
```

## Performance Optimization

### Efficient Prompting
```javascript
// â Good: Specific and clear requirements
async function efficientPrompt() {
  return await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: [
      "Calculate the factorial of 20 using an iterative approach. " +
      "Show the calculation steps and verify the result."
    ],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });
}

// â Less efficient: Vague requirements
async function vaguePrompt() {
  return await ai.models.generateContent({
    model: "gemini-2.5-flash",
    contents: ["Do some math calculations"],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });
}
```

### Batch Processing
```javascript
async function batchAnalysis(datasets) {
  const prompt = `
Analyze the following datasets and create a comprehensive report:

${datasets.map((dataset, index) => 
  `Dataset ${index + 1}: ${dataset.description}`
).join('\n')}

For each dataset:
1. Calculate summary statistics
2. Identify trends and patterns  
3. Create appropriate visualizations
4. Provide insights and recommendations

Generate a final comparison chart showing key metrics across all datasets.
`;

  const response = await ai.models.generateContent({
    model: "gemini-2.0-flash",
    contents: [prompt],
    config: {
      tools: [{ codeExecution: {} }],
    },
  });

  return response;
}
```

## Supported Libraries

The code execution environment includes these key libraries:

### Data Science & Analysis
- **pandas**: Data manipulation and analysis
- **numpy**: Numerical computing
- **scipy**: Scientific computing
- **scikit-learn**: Machine learning
- **sympy**: Symbolic mathematics

### Visualization
- **matplotlib**: Plotting and visualization
- **seaborn**: Statistical data visualization

### Image & Document Processing
- **opencv-python**: Computer vision
- **pillow**: Image processing
- **PyPDF2**: PDF manipulation
- **python-docx**: Word document processing
- **reportlab**: PDF generation

### Specialized Libraries
- **tensorflow**: Machine learning framework
- **geopandas**: Geographic data analysis
- **chess**: Chess game analysis
- **lxml**: XML processing

## Billing and Limitations

### Billing Model
- **Input tokens**: Original prompt + intermediate tokens (generated code + execution results)
- **Output tokens**: Final response including code, results, and summary
- **No additional charges**: Code execution itself is free

### Technical Limitations
- **Runtime limit**: 30 seconds maximum execution time
- **Language restriction**: Python only (can generate other languages but can't execute them)
- **Error retries**: Up to 5 automatic retries on execution errors
- **File size limits**: Up to 1 million tokens (~2MB for text files)
- **Library restrictions**: Cannot install custom libraries

### Supported File Types (Gemini 2.0+)
- **Input**: .png, .jpeg, .csv, .xml, .cpp, .java, .py, .js, .ts
- **Output**: Images generated via matplotlib/seaborn

## Integration Examples

### Express.js API Endpoint
```javascript
app.post('/api/analyze', async (req, res) => {
  try {
    const { prompt, fileData } = req.body;
    
    const contents = [prompt];
    if (fileData) {
      contents.unshift({
        inlineData: {
          mimeType: fileData.mimeType,
          data: fileData.data
        }
      });
    }

    const response = await ai.models.generateContent({
      model: "gemini-2.0-flash",
      contents,
      config: {
        tools: [{ codeExecution: {} }],
      },
    });

    const processed = processCodeExecutionResponse(response);
    
    res.json({
      success: true,
      text: processed.text.join('\n'),
      code: processed.code,
      output: processed.output,
      images: processed.images,
      errors: processed.errors
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### Real-time Data Analysis
```javascript
class DataAnalyzer {
  constructor() {
    this.ai = new GoogleGenAI({});
    this.chat = null;
  }

  async initialize() {
    this.chat = this.ai.chats.create({
      model: "gemini-2.5-flash",
      config: {
        tools: [{ codeExecution: {} }],
      },
    });
  }

  async analyzeData(data, analysisType = 'summary') {
    const prompts = {
      summary: "Provide summary statistics and basic insights for this data.",
      trends: "Identify trends, patterns, and anomalies in this data.",
      predictions: "Create predictive models and forecasts based on this data.",
      visualization: "Create comprehensive visualizations for this data."
    };

    const response = await this.chat.sendMessage({
      message: `${prompts[analysisType]}\n\nData: ${JSON.stringify(data)}`
    });

    return processCodeExecutionResponse(response);
  }

  async generateReport(data) {
    const response = await this.chat.sendMessage({
      message: `Create a comprehensive analytical report for this data including:
        1. Executive summary
        2. Statistical analysis  
        3. Visualizations
        4. Key insights and recommendations
        
        Data: ${JSON.stringify(data)}`
    });

    return processCodeExecutionResponse(response);
  }
}

// Usage
const analyzer = new DataAnalyzer();
await analyzer.initialize();
const results = await analyzer.analyzeData(salesData, 'trends');
```

## Best Practices Summary

1. **Clear Requirements**: Provide specific, detailed prompts for better code generation
2. **Error Handling**: Implement retry logic and proper error processing
3. **Response Processing**: Parse different response parts appropriately
4. **Model Selection**: Use Gemini 2.0+ for file I/O and advanced visualization features
5. **Performance**: Batch related analyses and use efficient prompting strategies
6. **Security**: Validate inputs and handle execution errors gracefully
7. **Resource Management**: Be mindful of execution time limits and token usage