# **Rust Design Patterns**

*the* rust-unofficial *authors*

## **Chapter 1: Introduction**

### **Design patterns**

In software development, we often come across problems that share similarities regardless of the environment they appear in. Although the implementation details are crucial to solve the task at hand, we may abstract from these particularities to find the common practices that are generically applicable.

Design patterns are a collection of reusable and tested solutions to recurring problems in engineering. They make our software more modular, maintainable, and extensible. Moreover, these patterns provide a common language for developers, making them an excellent tool for effective communication when problem-solving in teams.

**Keep in mind:** Each pattern comes with its own set of trade-offs. It's crucial to focus on why you choose a particular pattern rather than just on how to implement it.

### **Design patterns in Rust**

Rust is not object-oriented, and the combination of all its characteristics, such as functional elements, a strong type system, and the borrow checker, makes it unique. Because of this, Rust design patterns vary with respect to other traditional object-oriented programming languages. That's why we decided to write this book. We hope you enjoy reading it\! The book is divided in three main chapters:

* **Idioms:** guidelines to follow when coding. They are the social norms of the community. You should break them only if you have a good reason for it.  
* **Design patterns:** methods to solve common problems when coding.  
* **Anti-patterns:** methods to solve common problems when coding. However, while design patterns give us benefits, anti-patterns create more problems.

## **Chapter 2: Idioms**

Idioms are commonly used styles, guidelines and patterns largely agreed upon by a community. Writing idiomatic code allows other developers to understand better what is happening.

After all, the computer only cares about the machine code that is generated by the compiler. Instead, the source code is mainly beneficial to the developer. So, since we have this abstraction layer, why not make it more readable?

Remember the **KISS principle**: "Keep It Simple, Stupid". It claims that "most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided".

Code is there for humans, not computers, to understand.

### **2.1 Use borrowed types for arguments**

**Description**

Using a target of a deref coercion can increase the flexibility of your code when you are deciding which argument type to use for a function argument. In this way, the function will accept more input types.

This is not limited to slice-able or fat pointer types. In fact, you should always prefer using the borrowed type over borrowing the owned type. Such as \&str over \&String, &\[T\] over \&Vec\<T\>, or \&T over \&Box\<T\>.

Using borrowed types you can avoid layers of indirection for those instances where the owned type already provides a layer of indirection. For instance, a String has a layer of indirection, so a \&String will have two layers of indirection. We can avoid this by using \&str instead, and letting \&String coerce to a \&str whenever the function is invoked.

**Example**

fn three\_vowels(word: \&String) \-\> bool {  
    let mut vowel\_count \= 0;  
    for c in word.chars() {  
        match c {  
            'a' | 'e' | 'i' | 'o' | 'u' \=\> {  
                vowel\_count \+= 1;  
                if vowel\_count \>= 3 {  
                    return true;  
                }  
            }  
            \_ \=\> vowel\_count \= 0,  
        }  
    }  
    false  
}

fn main() {  
    let ferris \= "Ferris".to\_string();  
    let curious \= "Curious".to\_string();  
    println\!("{}: {}", ferris, three\_vowels(\&ferris));  
    println\!("{}: {}", curious, three\_vowels(\&curious));  
    // This works fine, but the following two lines would fail:  
    // println\!("Ferris: {}", three\_vowels("Ferris"));  
    // println\!("Curious: {}", three\_vowels("Curious"));  
}

This works fine because we are passing a \&String type as a parameter. If we remove the comments on the last two lines, the example will fail. This is because a \&str type will not coerce to a \&String type. We can fix this by simply modifying the type for our argument.

For instance, if we change our function declaration to:

fn three\_vowels(word: \&str) \-\> bool {  
    // ...  
}

Then both versions will compile and print the same output.

Ferris: false  
Curious: true

However, this example will not run when our function is declared with an argument type \&String. This is because string slices are a \&str and not a \&String which would require an allocation to be converted to \&String which is not implicit, whereas converting from String to \&str is cheap and implicit.

### **2.2 Concatenating strings with format\!**

**Description**

It is possible to build up strings using the push and push\_str methods on a mutable String, or using its \+ operator. However, it is often more convenient to use format\!, especially where there is a mix of literal and non-literal strings.

**Example**

fn say\_hello(name: \&str) \-\> String {  
    // We could construct the result string manually.  
    // let mut result \= "Hello ".to\_owned();  
    // result.push\_str(name);  
    // result.push('\!');  
    // result

    // But using format\! is better.  
    format\!("Hello {name}\!")  
}

**Advantages**

Using format\! is usually the most succinct and readable way to combine strings.

**Disadvantages**

It is usually not the most efficient way to combine strings \- a series of push operations on a mutable string is usually the most efficient (especially if the string has been pre-allocated to the expected size).

### **2.3 Constructors**

**Description**

Rust does not have constructors as a language construct. Instead, the convention is to use an associated function new to create an object:

/// Time in seconds.  
///  
/// \# Example  
///  
/// let s \= Second::new(42);  
/// assert\_eq\!(42, s.value());  
pub struct Second {  
    value: u64,  
}

impl Second {  
    // Constructs a new instance of \[Second\].  
    // Note this is an associated function no self.  
    pub fn new(value: u64) \-\> Self {  
        Self { value }  
    }

    /// Returns the value in seconds.  
    pub fn value(\&self) \-\> u64 {  
        self.value  
    }  
}

**Default Constructors**

Rust supports default constructors with the Default trait:

/// Time in seconds.  
///  
/// \# Example  
///  
/// let s \= Second::default();  
/// assert\_eq\!(0, s.value());  
///  
\#\[derive(Default)\]  
pub struct Second {  
    value: u64,  
}

impl Second {  
    /// Returns the value in seconds.  
    pub fn value(\&self) \-\> u64 {  
        self.value  
    }  
}

**Note:** It is common and expected for types to implement both Default and an empty new constructor. new is the constructor convention in Rust, and users expect it to exist, so if it is reasonable for the basic constructor to take no arguments, then it should, even if it is functionally identical to default.

### **2.4 The Default Trait**

**Description**

Many types in Rust have a constructor. However, this is specific to the type; Rust cannot abstract over "everything that has a new() method". To allow this, the Default trait was conceived, which can be used with containers and other generic types (e.g. see Option::unwrap\_or\_default()). Notably, some containers already implement it where applicable.

Not only do one-element containers like Cow, Box or Arc implement Default for contained Default types, one can automatically \#\[derive(Default)\] for structs whose fields all implement it, so the more types implement Default, the more useful it becomes.

On the other hand, constructors can take multiple arguments, while the default() method does not. There can even be multiple constructors with different names, but there can only be one Default implementation per type.

**Example**

use std::{path::PathBuf, time::Duration};

// note that we can simply auto-derive Default here.  
\#\[derive(Default, Debug, PartialEq)\]  
struct MyConfiguration {  
    // Option defaults to None  
    output: Option\<PathBuf\>,  
    // Vecs default to empty vector  
    search\_path: Vec\<PathBuf\>,  
    // Duration defaults to zero time  
    timeout: Duration,  
    // bool defaults to false  
    check: bool,  
}

impl MyConfiguration {  
    // add setters here  
}

fn main() {  
    // construct a new instance with default values  
    let mut conf \= MyConfiguration::default();  
    // do something with conf here  
    conf.check \= true;  
    println\!("conf \= {conf:\#?}");

    // partial initialization with default values, creates the same instance  
    let conf1 \= MyConfiguration {  
        check: true,  
        ..Default::default()  
    };  
    assert\_eq\!(conf, conf1);  
}

### **2.5 Collections are smart pointers**

**Description**

Use the Deref trait to treat collections like smart pointers, offering owning and borrowed views of data.

**Example**

use std::ops::Deref;

struct Vec\<T\> {  
    // data: RawVec\<T\>,  
    // ..  
}

impl\<T\> Deref for Vec\<T\> {  
    type Target \= \[T\];  
    fn deref(\&self) \-\> &\[T\] {  
        //..  
        unimplemented\!()  
    }  
}

A Vec\<T\> is an owning collection of Ts, while a slice (&\[T\]) is a borrowed collection of Ts. Implementing Deref for Vec allows implicit dereferencing from \&Vec\<T\> to &\[T\] and includes the relationship in auto-dereferencing searches. Most methods you might expect to be implemented for Vecs are instead implemented for slices.

Also String and \&str have a similar relation.

**Motivation**

Ownership and borrowing are key aspects of the Rust language. Data structures must account for these semantics properly to give a good user experience. When implementing a data structure that owns its data, offering a borrowed view of that data allows for more flexible APIs.

**Advantages**

* Most methods can be implemented only for the borrowed view, they are then implicitly available for the owning view.  
* Gives clients a choice between borrowing or taking ownership of data.

**Disadvantages**

Methods and traits only available via dereferencing are not taken into account when bounds checking, so generic programming with data structures using this pattern can get complex (see the Borrow and AsRef traits, etc.).

### **2.6 Finalisation in destructors**

**Description**

Rust does not provide the equivalent to finally blocks \- code that will be executed no matter how a function is exited. Instead, an object's destructor can be used to run code that must be run before exit.

**Example**

fn baz() \-\> Result\<(), ()\> {  
    // some code  
    Ok(())  
}

fn bar() \-\> Result\<(), ()\> {  
    // These don't need to be defined inside the function.  
    struct Foo;

    // Implement a destructor for Foo.  
    impl Drop for Foo {  
        fn drop(\&mut self) {  
            println\!("exit");  
        }  
    }

    // The dtor of exit will run however the function 'bar' is exited.  
    let \_exit \= Foo;

    // Implicit return with ? operator.  
    baz()?;

    // Normal return.  
    Ok(())  
}

**Motivation**

If a function has multiple return points, then executing code on exit becomes difficult and repetitive (and thus bug-prone). This is especially the case where return is implicit due to a macro. A common case is the ? operator which returns if the result is an Err, but continues if it is Ok. ? is used as an exception handling mechanism, but unlike Java (which has finally), there is no way to schedule code to run in both the normal and exceptional cases. Panicking will also exit a function early.

**Advantages**

Code in destructors will (nearly) always be run \- copes with panics, early returns, etc.

**Disadvantages**

* It is not guaranteed that destructors will run. For example, if there is an infinite loop in a function or if running a function crashes before exit. Destructors are also not run in the case of a panic in an already panicking thread. Therefore, destructors cannot be relied on as finalizers where it is absolutely essential that finalisation happens.  
* This pattern introduces some hard to notice, implicit code. Reading a function gives no clear indication of destructors to be run on exit. This can make debugging tricky.  
* Requiring an object and Drop impl just for finalisation is heavy on boilerplate.

### **2.7 mem::{take(\_), replace(\_)} to keep owned values in changed enums**

**Description**

Say we have a \&mut MyEnum which has (at least) two variants, A { name: String, x: u8 } and B { name: String }. Now we want to change MyEnum::A to a B if x is zero, while keeping MyEnum::B intact.

We can do this without cloning the name.

**Example**

use std::mem;

enum MyEnum {  
    A { name: String, x: u8 },  
    B { name: String },  
}

fn a\_to\_b(e: \&mut MyEnum) {  
    if let MyEnum::A { name, x: 0 } \= e {  
        // This takes out our name and puts in an empty String instead  
        // (note that empty strings don't allocate).  
        // Then, construct the new enum variant (which will  
        // be assigned to \`e\`).  
        \*e \= MyEnum::B {  
            name: mem::take(name),  
        }  
    }  
}

**Motivation**

When working with enums, we may want to change an enum value in place, perhaps to another variant. This is usually done in two phases to keep the borrow checker happy. In the first phase, we observe the existing value and look at its parts to decide what to do next. In the second phase we may conditionally change the value (as in the example above).

The borrow checker won't allow us to take out name of the enum (because something must be there.) We could of course .clone() name and put the clone into our MyEnum::B, but that would be an instance of the *Clone to satisfy the borrow checker* anti-pattern. Anyway, we can avoid the extra allocation by changing e with only a mutable borrow.

mem::take lets us swap out the value, replacing it with its default value, and returning the previous value. For String, the default value is an empty String, which does not need to allocate. As a result, we get the original name as an owned value. We can then wrap this in another enum.

**NOTE:** mem::replace is very similar, but allows us to specify what to replace the value with. An equivalent to our mem::take line would be mem::replace(name, String::new()).

Note, however, that if we are using an Option and want to replace its value with a None, Option's take() method provides a shorter and more idiomatic alternative.

### **2.8 On-Stack Dynamic Dispatch**

**Description**

We can dynamically dispatch over multiple values, however, to do so, we need to declare multiple variables to bind differently-typed objects. To extend the lifetime as necessary, we can use deferred conditional initialization, as seen below:

**Example**

use std::io;  
use std::fs;

\# fn main() \-\> Result\<(), Box\<dyn std::error::Error\>\> {  
\# let arg \= "-";  
// We need to describe the type to get dynamic dispatch.  
let readable: \&mut dyn io::Read \= if arg \== "-" {  
    \&mut io::stdin()  
} else {  
    \&mut fs::File::open(arg)?  
};  
// Read from \`readable\` here.  
\# Ok(())  
\# }

**Motivation**

Rust monomorphises code by default. This means a copy of the code will be generated for each type it is used with and optimized independently. While this allows for very fast code on the hot path, it also bloats the code in places where performance is not of the essence, thus costing compile time and cache usage.

Luckily, Rust allows us to use dynamic dispatch, but we have to explicitly ask for it.

**Advantages**

We do not need to allocate anything on the heap. Neither do we need to initialize something we won't use later, nor do we need to monomorphize the whole code that follows to work with both File or Stdin.

### **2.9 FFI Idioms**

#### **2.9.1 Error Handling in FFI**

**Description**

In foreign languages like C, errors are represented by return codes. However, Rust's type system allows much more rich error information to be captured and propagated through a full type.

This best practice shows different kinds of error codes, and how to expose them in a usable way:

1. **Flat Enums** should be converted to integers and returned as codes.  
2. **Structured Enums** should be converted to an integer code with a string error message for detail.  
3. **Custom Error Types** should become "transparent", with a C representation.

**Code Example**

*Flat Enums*

enum DatabaseError {  
    IsReadOnly \= 1,     // user attempted a write operation  
    IOError \= 2,        // user should read the C errno() for what it was  
    FileCorrupted \= 3,  // user should run a repair tool to recover it  
}

impl From\<DatabaseError\> for libc::c\_int {  
    fn from(e: DatabaseError) \-\> libc::c\_int {  
        (e as i8).into()  
    }  
}

*Structured Enums*

pub mod errors {  
    enum DatabaseError {  
        IsReadOnly,  
        IOError(std::io::Error),  
        FileCorrupted(String), // message describing the issue  
    }

    impl From\<DatabaseError\> for libc::c\_int {  
        fn from(e: DatabaseError) \-\> libc::c\_int {  
            match e {  
                DatabaseError::IsReadOnly \=\> 1,  
                DatabaseError::IOError(\_) \=\> 2,  
                DatabaseError::FileCorrupted(\_) \=\> 3,  
            }  
        }  
    }  
}

*Custom Error Types*

struct ParseError {  
    expected: char,  
    line: u32,  
    ch: u16,  
}

impl ParseError {  
    /\* Create a second version which is exposed as a C structure \*/  
}

\#\[repr(C)\]  
pub struct parse\_error {  
    pub expected: libc::c\_char,  
    pub line: u32,  
    pub ch: u16,  
}

impl From\<ParseError\> for parse\_error {  
    fn from(e: ParseError) \-\> parse\_error {  
        let ParseError { expected, line, ch } \= e;  
        parse\_error { expected: expected as libc::c\_char, line, ch }  
    }  
}

#### **2.9.2 Accepting Strings**

**Description**

When accepting strings via FFI through pointers, there are two principles that should be followed:

1. Keep foreign strings "borrowed", rather than copying them directly.  
2. Minimize the amount of complexity and unsafe code involved in converting from a C-style string to native Rust strings.

**Code Example**

pub mod unsafe\_module {  
    // other module content  
    /// Log a message at the specified level.  
    ///  
    /// \# Safety  
    ///  
    /// It is the caller's guarantee to ensure 'msg':  
    ///  
    /// \- is not a null pointer  
    /// \- points to valid, initialized data  
    /// \- points to memory ending in a null byte  
    /// \- won't be mutated for the duration of this function call  
    \#\[no\_mangle\]  
    pub unsafe extern "C" fn mylib\_log(msg: \*const libc::c\_char, level: libc::c\_int) {  
        // let level: crate::LogLevel \= match level { /\* ... \*/ };

        // SAFETY: The caller has already guaranteed this is okay (see the  
        // \# Safety section of the doc-comment).  
        let msg\_str: \&str \= match std::ffi::CStr::from\_ptr(msg).to\_str() {  
            Ok(s) \=\> s,  
            Err(e) \=\> {  
                // crate::log\_error("FFI string conversion failed");  
                return;  
            }  
        };

        // crate::log(msg\_str, level);  
    }  
}

#### **2.9.3 Passing Strings**

**Description**

When passing strings to FFI functions, there are four principles that should be followed:

1. Make the lifetime of owned strings as long as possible.  
2. Minimize unsafe code during the conversion.  
3. If the C code can modify the string data, use Vec instead of CString.  
4. Unless the Foreign Function API requires it, the ownership of the string should not transfer to the callee.

**Code Example**

pub mod unsafe\_module {  
    // other module content  
    extern "C" {  
        fn seterr(message: \*const libc::c\_char);  
        fn geterr(buffer: \*mut libc::c\_char, size: libc::c\_int) \-\> libc::c\_int;  
    }

    fn report\_error\_to\_ffi\<S: Into\<String\>\>(err: S) \-\> Result\<(), std::ffi::NulError\> {  
        let c\_err \= std::ffi::CString::new(err.into())?;  
        unsafe {  
            // SAFETY: calling an FFI whose documentation says the pointer is  
            // const, so no modification should occur  
            seterr(c\_err.as\_ptr());  
        }  
        Ok(())  
        // The lifetime of c\_err continues until here  
    }

    fn get\_error\_from\_ffi() \-\> Result\<String, std::ffi::IntoStringError\> {  
        let mut buffer \= vec\!\[0u8; 1024\];  
        unsafe {  
            // SAFETY: calling an FFI whose documentation implies  
            // that the input need only live as long as the call  
            let written: usize \= geterr(buffer.as\_mut\_ptr() as \*mut i8, 1023).into();  
            buffer.truncate(written \+ 1);  
            std::ffi::CString::new(buffer).unwrap().into\_string()  
        }  
    }  
}

### **2.10 Iterating over an Option**

**Description**

Option can be viewed as a container that contains either zero or one element. In particular, it implements the IntoIterator trait, and as such can be used with generic code that needs such a type.

**Examples**

Since Option implements IntoIterator, it can be used as an argument to .extend():

let turing \= Some("Turing");  
let mut logicians \= vec\!\["Curry", "Kleene", "Markov"\];  
logicians.extend(turing);

// equivalent to  
if let Some(turing\_inner) \= turing {  
    logicians.push(turing\_inner);  
}

If you need to tack an Option to the end of an existing iterator, you can pass it to chain():

let turing \= Some("Turing");  
let logicians \= vec\!\["Curry", "Kleene", "Markov"\];

for logician in logicians.iter().chain(turing.iter()) {  
    println\!("{logician} is a logician");  
}

### **2.11 Pass variables to closure**

**Description**

By default, closures capture their environment by borrowing. Or you can use a move-closure to move the whole environment. However, often you want to move just some variables to the closure, give it a copy of some data, pass by reference, or perform some other transformation.

Use variable rebinding in a separate scope for that.

**Example**

use std::rc::Rc;

let num1 \= Rc::new(1);  
let num2 \= Rc::new(2);  
let num3 \= Rc::new(3);

let closure \= {  
    // \`num1\` is moved  
    let num2 \= num2.clone(); // \`num2\` is cloned  
    let num3 \= num3.as\_ref(); // \`num3\` is borrowed  
    move || {  
        \*num1 \+ \*num2 \+ \*num3;  
    }  
};

### **2.12 \#\[non\_exhaustive\] and private fields for extensibility**

**Description**

A small set of scenarios exist where a library author may want to add public fields to a public struct or new variants to an enum without breaking backwards compatibility.

Rust offers two solutions to this problem:

* Use \#\[non\_exhaustive\] on structs, enums, and enum variants.  
* You may add a private field to a struct to prevent it from being directly instantiated or matched against.

**Example**

mod a {  
    // Public struct.  
    \#\[non\_exhaustive\]  
    pub struct S {  
        pub foo: i32,  
    }

    \#\[non\_exhaustive\]  
    pub enum AdmitMoreVariants {  
        VariantA,  
        VariantB,  
        \#\[non\_exhaustive\]  
        VariantC {  
            a: String,  
        },  
    }  
}

fn print\_matched\_variants(s: a::S) {  
    // Because S is \`\#\[non\_exhaustive\]\`, it cannot be named here and  
    // we must use \`..\` in the pattern.  
    let a::S { foo: \_, .. } \= s;

    let some\_enum \= a::AdmitMoreVariants::VariantA;  
    match some\_enum {  
        a::AdmitMoreVariants::VariantA \=\> println\!("it's an A"),  
        a::AdmitMoreVariants::VariantB \=\> println\!("it's a B"),  
        // \`..\` required because this variant is non-exhaustive as well  
        a::AdmitMoreVariants::VariantC { a, .. } \=\> println\!("it's a c"),  
        // The wildcard match is required because more variants may be  
        // added in the future  
        \_ \=\> println\!("it's a new variant"),  
    }  
}

### **2.13 Easy doc initialization**

**Description**

If a struct takes significant effort to initialize when writing docs, it can be quicker to wrap your example with a helper function which takes the struct as an argument.

**Example**

Instead of typing all of this boilerplate to create a Connection and Request, it is easier to just create a wrapping helper function which takes them as arguments:

\# struct Connection;  
\# struct Request;  
\# impl Connection {  
/// Sends a request over the connection.  
///  
/// \# Example  
///  
/// \`\`\`  
/// \# struct Connection;  
/// \# struct Request;  
/// \# impl Connection { fn send\_request(\&self, request: Request) \-\> Result\<(), ()\> { Ok(()) } }  
/// \# fn call\_send(connection: Connection, request: Request) {  
/// let response \= connection.send\_request(request);  
/// assert\!(response.is\_ok());  
/// \# }  
/// \`\`\`  
fn send\_request(\&self, request: Request) \-\> Result\<(), ()\> {  
    // ...  
    Ok(())  
}  
\# }

### **2.14 Temporary mutability**

**Description**

Often it is necessary to prepare and process some data, but after that data are only inspected and never modified. The intention can be made explicit by redefining the mutable variable as immutable.

It can be done either by processing data within a nested block or by redefining the variable.

**Example**

\# fn get\_vec() \-\> Vec\<i32\> { vec\!\[3, 1, 2\] }  
// Using nested block:  
let data \= {  
    let mut data \= get\_vec();  
    data.sort();  
    data  
};  
// Here data is immutable.

// Using variable rebinding:  
let mut data \= get\_vec();  
data.sort();  
let data \= data;  
// Here data is immutable.

### **2.15 Return consumed argument on error**

**Description**

If a fallible function consumes (moves) an argument, return that argument back inside an error.

**Example**

pub fn send(value: String) \-\> Result\<(), SendError\> {  
    println\!("using {value} in a meaningful way");  
    // Simulate non-deterministic fallible action.  
    use std::time::SystemTime;  
    let period \= SystemTime::now()  
        .duration\_since(SystemTime::UNIX\_EPOCH)  
        .unwrap();  
    if period.subsec\_nanos() % 2 \== 1 {  
        Ok(())  
    } else {  
        Err(SendError(value))  
    }  
}

pub struct SendError(String);

fn main() {  
    let mut value \= "imagine this is very long string".to\_string();  
    let success \= 's: {  
        // Try to send value two times.  
        for \_ in 0..2 {  
            value \= match send(value) {  
                Ok(()) \=\> break 's true,  
                Err(SendError(value)) \=\> value,  
            }  
        }  
        false  
    };  
    println\!("success: {success}");  
}

## **Chapter 3: Design Patterns**

Design patterns are "general reusable solutions to a commonly occurring problem within a given context in software design". Design patterns are a great way to describe the culture of a programming language. Design patterns are very language-specific \- what is a pattern in one language may be unnecessary in another due to a language feature, or impossible to express due to a missing feature. If overused, design patterns can add unnecessary complexity to programs. However, they are a great way to share intermediate and advanced level knowledge about a programming language.

### **3.1 Behavioural Patterns**

#### **3.1.1 Command**

**Description**

The basic idea of the Command pattern is to separate out actions into its own objects and pass them as parameters.

**Example**

pub trait Migration {  
    fn execute(\&self) \-\> \&str;  
    fn rollback(\&self) \-\> \&str;  
}

pub struct CreateTable;  
impl Migration for CreateTable {  
    fn execute(\&self) \-\> \&str { "create table" }  
    fn rollback(\&self) \-\> \&str { "drop table" }  
}

pub struct AddField;  
impl Migration for AddField {  
    fn execute(\&self) \-\> \&str { "add field" }  
    fn rollback(\&self) \-\> \&str { "remove field" }  
}

struct Schema {  
    commands: Vec\<Box\<dyn Migration\>\>,  
}

impl Schema {  
    fn new() \-\> Self { Self { commands: vec\!\[\] } }  
    fn add\_migration(\&mut self, cmd: Box\<dyn Migration\>) { self.commands.push(cmd); }  
    fn execute(\&self) \-\> Vec\<\&str\> { self.commands.iter().map(|cmd| cmd.execute()).collect() }  
    fn rollback(\&self) \-\> Vec\<\&str\> { self.commands.iter().rev().map(|cmd| cmd.rollback()).collect() }  
}

fn main() {  
    let mut schema \= Schema::new();  
    schema.add\_migration(Box::new(CreateTable));  
    schema.add\_migration(Box::new(AddField));

    assert\_eq\!(vec\!\["create table", "add field"\], schema.execute());  
    assert\_eq\!(vec\!\["remove field", "drop table"\], schema.rollback());  
}

#### **3.1.2 Interpreter**

**Description**

If a problem occurs very often and requires long and repetitive steps to solve it, then the problem instances might be expressed in a simple language and an interpreter object could solve it by interpreting the sentences written in this simple language.

**Example**

pub struct Interpreter\<'a\> {  
    it: std::str::Chars\<'a\>,  
}

impl\<'a\> Interpreter\<'a\> {  
    pub fn new(infix: &'a str) \-\> Self {  
        Self { it: infix.chars() }  
    }

    fn next\_char(\&mut self) \-\> Option\<char\> {  
        self.it.next()  
    }

    pub fn interpret(\&mut self, out: \&mut String) {  
        self.term(out);  
        while let Some(op) \= self.next\_char() {  
            if op \== '+' || op \== '-' {  
                self.term(out);  
                out.push(op);  
            } else {  
                panic\!("Unexpected symbol '{op}'");  
            }  
        }  
    }

    fn term(\&mut self, out: \&mut String) {  
        match self.next\_char() {  
            Some(ch) if ch.is\_digit(10) \=\> out.push(ch),  
            Some(ch) \=\> panic\!("Unexpected symbol '{ch}'"),  
            None \=\> panic\!("Unexpected end of string"),  
        }  
    }  
}

pub fn main() {  
    let mut intr \= Interpreter::new("2+3");  
    let mut postfix \= String::new();  
    intr.interpret(\&mut postfix);  
    assert\_eq\!(postfix, "23+");  
}

#### **3.1.3 Newtype**

**Description**

Use a tuple struct with a single field to make an opaque wrapper for a type. This creates a new type, rather than an alias to a type (type items).

**Example**

use std::fmt::Display;

// Create Newtype Password to override the Display trait for String  
struct Password(String);

impl Display for Password {  
    fn fmt(\&self, f: \&mut std::fmt::Formatter\<'\_\>) \-\> std::fmt::Result {  
        write\!(f, "\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*")  
    }  
}

fn main() {  
    let unsecured\_password: String \= "ThisIsMyPassword".to\_string();  
    let secured\_password: Password \= Password(unsecured\_password.clone());  
    println\!("unsecured\_password: {unsecured\_password}");  
    println\!("secured\_password: {secured\_password}");  
}

#### **3.1.4 RAII with guards**

**Description**

RAII stands for "Resource Acquisition is Initialisation" which is a terrible name. The essence of the pattern is that resource initialisation is done in the constructor of an object and finalisation in the destructor. This pattern is extended in Rust by using a RAII object as a guard of some resource and relying on the type system to ensure that access is always mediated by the guard object.

**Example**

use std::ops::Deref;

struct Foo {}  
impl Foo { fn foo(\&self) {} }

struct Mutex\<T\> { data: T }

struct MutexGuard\<'a, T: 'a\> {  
    data: &'a T,  
}

impl\<T\> Mutex\<T\> {  
    fn lock(\&self) \-\> MutexGuard\<T\> {  
        MutexGuard { data: \&self.data }  
    }  
}

impl\<'a, T\> Drop for MutexGuard\<'a, T\> {  
    fn drop(\&mut self) {  
        // Unlock the underlying OS mutex.  
    }  
}

impl\<'a, T\> Deref for MutexGuard\<'a, T\> {  
    type Target \= T;  
    fn deref(\&self) \-\> \&T {  
        self.data  
    }  
}

fn baz(x: Mutex\<Foo\>) {  
    let xx \= x.lock();  
    xx.foo(); // foo is a method on Foo.  
    // x is unlocked when we exit this function and xx's destructor is executed.  
}

#### **3.1.5 Strategy (aka Policy)**

**Description**

The Strategy design pattern is a technique that enables separation of concerns. It also allows to decouple software modules through Dependency Inversion.

The basic idea behind the Strategy pattern is that, given an algorithm solving a particular problem, we define only the skeleton of the algorithm at an abstract level, and we separate the specific algorithm's implementation into different parts.

**Example**

use std::collections::HashMap;

type Data \= HashMap\<String, u32\>;

trait Formatter {  
    fn format(\&self, data: \&Data, buf: \&mut String);  
}

struct Report;

impl Report {  
    fn generate\<T: Formatter\>(g: T, s: \&mut String) {  
        let mut data \= HashMap::new();  
        data.insert("one".to\_string(), 1);  
        data.insert("two".to\_string(), 2);  
        g.format(\&data, s);  
    }  
}

struct Text;  
impl Formatter for Text {  
    fn format(\&self, data: \&Data, buf: \&mut String) {  
        for (k, v) in data {  
            let entry \= format\!("{k} {v}\\n");  
            buf.push\_str(\&entry);  
        }  
    }  
}

struct Json;  
impl Formatter for Json {  
    fn format(\&self, data: \&Data, buf: \&mut String) {  
        buf.push('\[');  
        for (i, (k, v)) in data.into\_iter().enumerate() {  
            let entry \= format\!(r\#"{{"{}":"{}"}}"\#, k, v);  
            buf.push\_str(\&entry);  
            if i \< data.len() \- 1 {  
                buf.push(',');  
            }  
        }  
        buf.push('\]');  
    }  
}

fn main() {  
    let mut s \= String::from("");  
    Report::generate(Text, \&mut s);  
    assert\!(s.contains("one 1"));  
    assert\!(s.contains("two 2"));

    s.clear();  
    Report::generate(Json, \&mut s);  
    assert\!(s.contains(r\#"{"one":"1"}"\#));  
    assert\!(s.contains(r\#"{"two":"2"}"\#));  
}

#### **3.1.6 Visitor**

**Description**

A visitor encapsulates an algorithm that operates over a heterogeneous collection of objects. It allows multiple different algorithms to be written over the same data without having to modify the data (or their primary behaviour).

**Example**

// The data we will visit  
mod ast {  
    pub enum Stmt { Expr(Expr), Let(Name, Expr) }  
    pub struct Name { value: String }  
    pub enum Expr { IntLit(i64), Add(Box\<Expr\>, Box\<Expr\>), Sub(Box\<Expr\>, Box\<Expr\>) }  
}

// The abstract visitor  
mod visit {  
    use super::ast::\*;  
    pub trait Visitor\<T\> {  
        fn visit\_name(\&mut self, n: \&Name) \-\> T;  
        fn visit\_stmt(\&mut self, s: \&Stmt) \-\> T;  
        fn visit\_expr(\&mut self, e: \&Expr) \-\> T;  
    }  
}

use ast::\*;  
use visit::\*;

// An example concrete implementation walks the AST interpreting it as code.  
struct Interpreter;  
impl Visitor\<i64\> for Interpreter {  
    fn visit\_name(\&mut self, n: \&Name) \-\> i64 { panic\!() }  
    fn visit\_stmt(\&mut self, s: \&Stmt) \-\> i64 {  
        match \*s {  
            Stmt::Expr(ref e) \=\> self.visit\_expr(e),  
            Stmt::Let(..) \=\> unimplemented\!(),  
        }  
    }  
    fn visit\_expr(\&mut self, e: \&Expr) \-\> i64 {  
        match \*e {  
            Expr::IntLit(n) \=\> n,  
            Expr::Add(ref lhs, ref rhs) \=\> self.visit\_expr(lhs) \+ self.visit\_expr(rhs),  
            Expr::Sub(ref lhs, ref rhs) \=\> self.visit\_expr(lhs) \- self.visit\_expr(rhs),  
        }  
    }  
}

### **3.2 Creational Patterns**

#### **3.2.1 Builder**

**Description**

Construct an object with calls to a builder helper.

**Example**

\#\[derive(Debug, PartialEq)\]  
pub struct Foo {  
    bar: String,  
}

impl Foo {  
    pub fn builder() \-\> FooBuilder {  
        FooBuilder::default()  
    }  
}

\#\[derive(Default)\]  
pub struct FooBuilder {  
    bar: String,  
}

impl FooBuilder {  
    pub fn new() \-\> FooBuilder {  
        FooBuilder { bar: String::from("X") }  
    }

    pub fn name(mut self, bar: String) \-\> FooBuilder {  
        self.bar \= bar;  
        self  
    }

    pub fn build(self) \-\> Foo {  
        Foo { bar: self.bar }  
    }  
}

\#\[test\]  
fn builder\_test() {  
    let foo \= Foo { bar: String::from("Y") };  
    let foo\_from\_builder: Foo \= FooBuilder::new().name(String::from("Y")).build();  
    assert\_eq\!(foo, foo\_from\_builder);  
}

#### **3.2.2 Fold**

**Description**

Run an algorithm over each item in a collection of data to create a new item, thus creating a whole new collection.

**Example**

// The data we will fold, a simple AST.  
mod ast {  
    pub enum Stmt { Expr(Box\<Expr\>), Let(Box\<Name\>, Box\<Expr\>) }  
    pub struct Name { pub value: String }  
    pub enum Expr { IntLit(i64), Add(Box\<Expr\>, Box\<Expr\>), Sub(Box\<Expr\>, Box\<Expr\>) }  
}

// The abstract folder  
mod fold {  
    use super::ast::\*;  
    pub trait Folder {  
        fn fold\_name(\&mut self, n: Box\<Name\>) \-\> Box\<Name\> { n }  
        fn fold\_stmt(\&mut self, s: Box\<Stmt\>) \-\> Box\<Stmt\> {  
            match \*s {  
                Stmt::Expr(e) \=\> Box::new(Stmt::Expr(self.fold\_expr(e))),  
                Stmt::Let(n, e) \=\> Box::new(Stmt::Let(self.fold\_name(n), self.fold\_expr(e))),  
            }  
        }  
        fn fold\_expr(\&mut self, e: Box\<Expr\>) \-\> Box\<Expr\> {  
            // ... similar to fold\_stmt  
            e  
        }  
    }  
}

use fold::\*;  
use ast::\*;

// An example concrete implementation renames every name to 'foo'.  
struct Renamer;  
impl Folder for Renamer {  
    fn fold\_name(\&mut self, n: Box\<Name\>) \-\> Box\<Name\> {  
        Box::new(Name { value: "foo".to\_owned() })  
    }  
}

### **3.3 Structural Patterns**

#### **3.3.1 Struct decomposition for independent borrowing**

**Description**

Sometimes a large struct will cause issues with the borrow checker \- although fields can be borrowed independently, sometimes the whole struct ends up being used at once, preventing other uses. A solution might be to decompose the struct into several smaller structs. Then compose these together into the original struct. Then each struct can be borrowed separately and have more flexible behaviour.

**Example**

\#\[derive(Debug, Clone)\]  
struct ConnectionString(String);

\#\[derive(Debug, Clone, Copy)\]  
struct Timeout(u32);

\#\[derive(Debug, Clone, Copy)\]  
struct PoolSize(u32);

struct Database {  
    connection\_string: ConnectionString,  
    timeout: Timeout,  
    pool\_size: PoolSize,  
}

fn print\_database(connection\_str: ConnectionString, timeout: Timeout, pool\_size: PoolSize) {  
    println\!("Connection string: {connection\_str:?}");  
    println\!("Timeout: {timeout:?}");  
    println\!("Pool size: {pool\_size:?}");  
}

fn main() {  
    let mut db \= Database {  
        connection\_string: ConnectionString("localhost".to\_string()),  
        timeout: Timeout(30),  
        pool\_size: PoolSize(100),  
    };

    let connection\_string \= \&mut db.connection\_string;  
    print\_database(connection\_string.clone(), db.timeout, db.pool\_size);  
    \*connection\_string \= ConnectionString("new string".to\_string());  
}

#### **3.3.2 Prefer small crates**

**Description**

Prefer small crates that do one thing well. Cargo and crates.io make it easy to add third-party libraries, much more so than in say C or C++.

**Advantages**

* Small crates are easier to understand, and encourage more modular code.  
* Crates allow for re-using code between projects.  
* Splitting a project into multiple crates can allow more of the code to be built in parallel.

**Disadvantages**

* This can lead to "dependency hell".  
* Packages on crates.io are not curated.  
* Two small crates may be less optimized than one large one.

#### **3.3.3 Contain unsafety in small modules**

**Description**

If you have unsafe code, create the smallest possible module that can uphold the needed invariants to build a minimal safe interface upon the unsafety. Embed this into a larger module that contains only safe code and presents an ergonomic interface.

**Advantages**

* This restricts the unsafe code that must be audited.  
* Writing the outer module is much easier, since you can count on the guarantees of the inner module.

### **3.4 FFI Patterns**

#### **3.4.1 Object-Based APIs**

**Description**

When designing APIs in Rust which are exposed to other languages, there are some important design principles which are contrary to normal Rust API design:

1. All Encapsulated types should be owned by Rust, managed by the user, and opaque.  
2. All Transactional data types should be owned by the user, and transparent.  
3. All library behavior should be functions acting upon Encapsulated types.  
4. All library behavior should be encapsulated into types not based on structure, but provenance/lifetime.

#### **3.4.2 Type Consolidation into Wrappers**

**Description**

This pattern is designed to allow gracefully handling multiple related types, while minimizing the surface area for memory unsafety. The lowest risk API is the "consolidated wrapper", where all possible interactions with an object are folded into a "wrapper type", while keeping the Rust API clean.

**Example**

\# use std::collections::BTreeSet;  
\# type Key \= String;  
\# type MySet \= BTreeSet\<Key\>;  
struct MySetWrapper {  
    myset: MySet,  
    iter\_next: usize,  
}

impl MySetWrapper {  
    pub fn first\_key(\&mut self) \-\> Option\<\&Key\> {  
        self.iter\_next \= 0;  
        self.next\_key()  
    }

    pub fn next\_key(\&mut self) \-\> Option\<\&Key\> {  
        if let Some(next) \= self.myset.iter().nth(self.iter\_next) {  
            self.iter\_next \+= 1;  
            Some(next)  
        } else {  
            None  
        }  
    }  
}

## **Chapter 4: Anti-patterns**

An anti-pattern is a solution to a "recurring problem that is usually ineffective and risks being highly counterproductive". Just as valuable as knowing how to solve a problem, is knowing how not to solve it.

### **4.1 Clone to satisfy the borrow checker**

**Description**

The borrow checker prevents Rust users from developing otherwise unsafe code by ensuring that either: only one mutable reference exists, or potentially many but all immutable references exist. If the code written does not hold true to these conditions, this anti-pattern arises when the developer resolves the compiler error by cloning the variable.

**Example**

// define any variable  
let mut x \= 5;

// Borrow x \-- but clone it first  
let y \= \&mut (x.clone());

// without the x.clone() two lines prior, this line would fail on compile as  
// x has been borrowed  
// thanks to x.clone(), x was never borrowed, and this line will run.  
println\!("{x}");

// perform some action on the borrow to prevent rust from optimizing this  
// out of existence  
\*y \+= 1;

### **4.2 \#\!\[deny(warnings)\]**

**Description**

A well-intentioned crate author wants to ensure their code builds without warnings. So they annotate their crate root with \#\!\[deny(warnings)\].

**Drawbacks**

By disallowing the compiler to build with warnings, a crate author opts out of Rust's famed stability. Sometimes new features or old misfeatures need a change in how things are done, thus lints are written that warn for a certain grace period before being turned to deny.

**Alternatives**

* Run RUSTFLAGS="-D warnings" cargo build in your CI.  
* Name the lints you want to deny explicitly.

### **4.3 Deref polymorphism**

**Description**

Misuse the Deref trait to emulate inheritance between structs, and thus reuse methods.

**Example**

use std::ops::Deref;

struct Foo {}  
impl Foo {  
    fn m(\&self) { /\*..\*/ }  
}

struct Bar {  
    f: Foo,  
}

impl Deref for Bar {  
    type Target \= Foo;  
    fn deref(\&self) \-\> \&Foo {  
        \&self.f  
    }  
}

fn main() {  
    let b \= Bar { f: Foo {} };  
    b.m();  
}

**Disadvantages**

* This is a surprising idiom.  
* It does not introduce subtyping between Foo and Bar.  
* Traits implemented by Foo are not automatically implemented for Bar.  
* It only supports single inheritance.

## **Chapter 5: Functional Usage of Rust**

Rust is an imperative language, but it follows many functional programming paradigms.

### **5.1 Programming paradigms**

One of the biggest hurdles to understanding functional programs when coming from an imperative background is the shift in thinking. Imperative programs describe *how* to do something, whereas declarative programs describe *what* to do.

**Imperative Sum**

let mut sum \= 0;  
for i in 1..11 {  
    sum \+= i;  
}  
println\!("{sum}"); // 55

**Declarative Sum**

println\!("{}", (1..11).fold(0, |a, b| a \+ b)); // 55

### **5.2 Generics as Type Classes**

**Description**

Rust's type system is designed more like functional languages (like Haskell) rather than imperative languages (like Java and C++). A key part of this idea is the way generic types work. In Rust, a generic type parameter creates what is known in functional languages as a "type class constraint